# 7. Vulnerability Assessment

During the course, we have covered different topics which can be thought as problems in cyber security, or more specifically, as *weaknesses*, which could result into vulnerabilities in different contexts. 
Especially, the concept of Common Weakness Enumeration (CWE) was handled on the week about the data input security.

If we want to prevent known things to happen again or cause impact for our own software, we need to consider different things on our software engineering process.
Not only in our threat and risk modelling process, but during the development and deployment of our products.
Our software is not the only attack vector — also all its dependencies and runtime environments are also part of it, better known as [Software Bill of Materials (SBOM)](#Software-Bill-of-Materials).

What if there are specific kinds of weaknesses which can happen similarly between different applications of the same technology?
In the code level, there might be a specific way to program to cause bugs, or there might be a common misconfiguration for a system.


For example, with manual inspection or automated testing, like fuzzing, we can identify new weaknesses and *vulnerabilities* in the software.
What if the vulnerability is in the specific software and in the specific software version, and we want to share the details about it? These details are usually better known as [CVEs.](#CVEs)

Similar thoughts can be also adapted on testing external software about vulnerabilities; does it software with known vulnerabilities or does its code or configuration environment include known mistakes?

## Software Bill of Materials



## CVEs

**Common vulnerabilities and exposures** or **CVE**'s are a list of known security threats that are contained into a single database. Each CVE is assigned its own unique ID for identification and documentation. This way, the same security risk can be identified by many organisations or personnel, and possible mitigated beforehand.

CVEs documentation provides information about the vulnerabilities. They typically include information as follows.

- Description
- Affected software
- Severity
- Impact

See the official [CVE website](https://www.cve.org/) for more information.

Managing a database of security threats also allows us to find vulnerabilities, prioritise high priority vulnerabilities and categorise them for example based on attack type (**CWE** in week 5).

![CVE details](cvedetails.png)
Source: [Vulnerabilities By Types/Categories, by CVEdetails](https://www.cvedetails.com/vulnerabilities-by-types.php)
## Grading

| Task # | Points | Description                                                           |
| ------ | :----: | --------------------------------------------------------------------- |
| Task 1 |   3    | Mitigation against known weaknesses and vulnerabilities (Moodle exam) |
| Task 2 |   2    | A tool case study (GitHub)                                            |

## Task 1C) Operations Security

Operations security (OPSEC) [^1], is a term more commonly known from military.
It typically means a process that prevents sensitive information to be observed by enemy intelligence, or in generally speaking, from getting it into the wrong hands.

This applies also in cyber security; our security is fundamentally based on the **unpredictability** and use of secrets, like passwords or cryptographic private keys.
What if you make a perfectly secure software, but leak all the secrets which are required for deploying and running it in production?

The problem is known to be wide. 
For example, recent 38 TB data breach from 2023 from Microsoft was a result of [leaked secret in GitHub](https://www.wiz.io/blog/38-terabytes-of-private-data-accidentally-exposed-by-microsoft-ai-researchers).

Different platforms have adapted secret scanning services.
For example, GitHub has quite extensive [features](https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning) to mitigate that this would not happen, while it cannot cover all the cases.

What if we take a look at some GitHub repository as an example, which hasn't taken good care about the secrets?



## Task 2: A tool case study: improving the software security (2p)

Choose one freely available tool that is primarily marketed for increasing software security. However, when you select a tool, it must be one that has a direct impact on software development or operational deployment. Do not select a product such as a firewall, a VPN, an IDS or antivirus software. 

You can also use a tool covered in previous exercises, but try to emphasize the software engineering aspects of it.   

Once you have selected a tool, read some of its marketing material. Things like feature lists, white papers, user guides, and demo videos would be useful resources. Make note of the arguments that it is being sold on, what it exactly does (“scanning” is a bit too high level description) and what is the tool expected to deliver.

> What to return

Answer the following questions about where the tool would fit in increasing security in a software project. Please copy each bullet point into your submission and answer directly under that bullet point.

Only a few sentences per bullet point, below, are necessary. However, ensure your own analysis shows through.

- Which tool did you research?
- Which general software development activity would the tool be used in? (E.g., project governance, training, product management, design, implementation, testing, deployment, operations.). Does it map to any SAMM [^11] [^12] activity, and if yes, which one?  
    
- What does the tool, technically speaking, do?
- In that specific area of software development, what does the tool not help with that would still need to be done?
- What types of risks does the tool mitigate?
- What sort of difficulties would you foresee when introducing the tool into a real-world software project - and crucially, _why_ you think you might run into these issues? (Examples of problems could be: Does it need specialists to run; does it scale into a large organisation; would it need a lot of work to get into use; would it be accepted by developers under time pressure; would it slow down development / integration / testing; would it require manual work or integrate in the toolchain or automation; would it fit agile development; and so on.).
- Try the tool in real life (on some real code). Describe how you would include it in a CI/CD pipeline (if applicable)  
    

There is no minimum length; it is when you think you’ve answered the questions sufficiently to convey your own analysis. 500 words should be more than enough for a good answer.

### Grading notes

Your score will depend on how well your analysis targets the last questions. You should aim to answer the ‘why’ part of why you think a certain tool has problems. Just saying what difficulties you foresee, without explaining why, will not achieve a high score.

[1]: [Operations security](https://en.wikipedia.org/wiki/Operations_security) 

[11]: [OWASP SAMM](https://owasp.org/www-project-samm/)
[12]: [SAMM model overview](https://owaspsamm.org/model/)